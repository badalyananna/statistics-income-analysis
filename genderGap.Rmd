---
title: "Untitled"
author: "Anna Badalyan"
date: "07 06 2022"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Cleaning the dataset
```{r}
curPop <- read.csv("C:\\Users\\Anna\\Documents\\Personal_files\\Uni_DS\\Courses\\Statistical_Learning\\Mod_B\\project\\gender_gap_dataset\\CurrentPopulationSurvey.csv")

dim(curPop)

```
The dataset contains 344287 observations and 234 variables.

Let's print the summary of the first 122 variables.
```{r}
summary(curPop[,1:122])

```
We can see that variables with a prefix o_  taken from the original Current Population survey, aren't cleaned, so we will use the version without the prefix. We can also notice that the variables gq, month, popstat, labforce, incbus, incfarm aren't informative as they contain the same value (their min, max and mean are the same), so we can drop them.
Many variables are categorical, but R reads them as numbers. We will need to represent them as factors for further modeling. The list of these variables is the following:
region, statefip, metro, metarea, relate, sex, race, marst, bpl, 
citizen, mbpl, fbpl, nativity, hispan, sch, empstat, classwkr, classwly, occ, ind, occ1990, ind1990, occ1950, ind1950, occly, indly, occ50ly, ind50ly, wkswork2, wkswork1, union, srcearn, ftype

Let's print the summary of the remaining columns:
```{r}
summary(curPop[,123:ncol(curPop)])
```
In the second part of the dataset, most of the variables were generated using the original 60 variables, however, it would be easier to take the occupation and industry variables using the already available dummy variables.

```{r}
curPop$industry[curPop$Agriculture == 1] <- 'Agriculture'
curPop$industry[curPop$miningconstruction == 1] <- 'MiningConstruction'
curPop$industry[curPop$durables == 1] <- 'Durables'
curPop$industry[curPop$nondurables == 1] <- 'Nondurables'
curPop$industry[curPop$Transport == 1] <- 'Transport'
curPop$industry[curPop$Utilities == 1] <- 'Utilities'
curPop$industry[curPop$Communications == 1] <- 'Communications'
curPop$industry[curPop$retailtrade == 1] <- 'RetailTrade'
curPop$industry[curPop$wholesaletrade == 1] <- 'WholesaleTrade'
curPop$industry[curPop$finance == 1] <- 'Finance'
curPop$industry[curPop$SocArtOther == 1] <- 'SocArtOther'
curPop$industry[curPop$hotelsrestaurants == 1] <- 'HotelsRestaurants'
curPop$industry[curPop$Medical == 1] <- 'Medical'
curPop$industry[curPop$Education == 1] <- 'Education'
curPop$industry[curPop$professional == 1] <- 'Professional'
curPop$industry[curPop$publicadmin == 1] <- 'Publicadmin'

curPop$occupation[curPop$manager == 1] <- 'manager'
curPop$occupation[curPop$business == 1] <- 'business'
curPop$occupation[curPop$financialop == 1] <- 'financialop'
curPop$occupation[curPop$computer == 1] <- 'computer'
curPop$occupation[curPop$architect == 1] <- 'architect'
curPop$occupation[curPop$scientist == 1] <- 'scientist'
curPop$occupation[curPop$socialworker == 1] <- 'socialworker'
curPop$occupation[curPop$postseceduc == 1] <- 'postseceduc'
curPop$occupation[curPop$legaleduc == 1] <- 'legaleduc'
curPop$occupation[curPop$artist == 1] <- 'artist'
curPop$occupation[curPop$lawyerphysician == 1] <- 'lawyerphysician'
curPop$occupation[curPop$healthcare == 1] <- 'healthcare'
curPop$occupation[curPop$healthsupport == 1] <- 'healthsupport'
curPop$occupation[curPop$protective == 1] <- 'protective'
curPop$occupation[curPop$foodcare == 1] <- 'foodcare'
curPop$occupation[curPop$building == 1] <- 'building'
curPop$occupation[curPop$sales == 1] <- 'sales'
curPop$occupation[curPop$officeadmin == 1] <- 'officeadmin'
curPop$occupation[curPop$farmer == 1] <- 'farmer'
curPop$occupation[curPop$constructextractinstall == 1] <- 'constructextractinstall'
curPop$occupation[curPop$production == 1] <- 'production'
curPop$occupation[curPop$transport == 1] <- 'transport'

print(unique(curPop$industry))
print(unique(curPop$occupation))

```
We can see, then newly generated values don't contain any null values.

As the year ranges from 1981 to 2013, we will need the inflation variable (*inflate*) and for convenience we will also use *realhrwage* variable.

We can see that we have several variables for income, which seem identical, *incwage*, *niincwage*, *incwageman*.
Let's check if they are identical:
```{r}
sum(incwage == niincwage) == sum(incwage == incwageman)
```
We verified, that the variables are identical, so we will only use the *incwage* column.
Another column for wage is *tcincwage*. Let's plot the boxplots to compare it with the *incwage*.

```{r}
boxplot(incwage, tcincwage)
```
We can see that the values are similar for the income below 200 000, however, the *incwage* contains more extreme values. However, as *incwageman* column includes imputed values, we will stick to *incwage*.

Thus, we chose the following columns:
```{r}
data <- curPop[c("year", "serial", "numprec", "hwtsupp", "region", "statefip", "metro", "metarea", "county", "pernum", "wtsupp", "relate", "age", "sex", "race", "marst", "bpl", "yrimmig", "citizen", "mbpl", "fbpl", "nativity", "hispan", "sch","educ99", "schlcoll", "empstat", "occupation", "industry", "classwkr", "occly", "indly", "classwly", "wkswork1", "hrswork", "uhrswork", "union", "incwage", "inclongj", "oincwage", "srcearn","ftype", "quhrswor", "qwkswork", "qinclong", "qincwage", "hrwage", "inflate", "realhrwage")]
```

Next we represent the necessary columns as factors.

```{r}
col.list <- c("region", "statefip", "metro", "metarea", "county", "relate", "sex", "race", "marst", "bpl", "citizen", "mbpl", "fbpl", "nativity", "hispan", "sch","educ99", "schlcoll", "empstat", "occupation", "industry", "classwkr", "occly", "indly", "classwly", "union", "srcearn","ftype", "quhrswor", "qwkswork", "qinclong", "qincwage")

for (col in col.list) {
  data[[col]] <- as.factor(data[[col]])
}

summary(data)
```
We can notice now that the source of earnings column (*srcearn*) is not informative as it contains only 47 observations for class 4, while the rest 301861 belong to class 1, so we can omit it.

```{r}
data$srcearn <- NULL
```


Let's print the null values in each column.
```{r}
colSums(is.na(data))
```
We can see that columns *yrimmig*, *citizen* and *schlcoll* contain almost 300000  null values. Column *metarea* is missing almost third of the observations, while it just provides a precise code for a metropolitan area. Column *educ99* contains the same information as *sch*. Thus, thise columns can be removed.

```{r}
data$yrimmig <- NULL
data$citizen <- NULL
data$schlcoll <- NULL
data$metarea <- NULL
data$educ99 <- NULL
data$county <- NULL
colSums(is.na(data))
```
Now, we can omit the null values.
```{r}
data <- na.omit(data)
summary(data)
```
We can notice that after cleaning the data
## Selecting the variables

Let's plot the distribution of the *incwage*.
```{r}
hist(data$incwage)
```

We can see that the distribution is highly left skewed. Thus, we might need to use the log of income.

Let's plot the *sch* column for education.

```{r}
barplot(table(data$sch))
```
We can see that there are very few values for people that didn't finish school, so we can group them by elementary, middle and high.

```{r}
levels(data$sch) <- c(levels(data$sch),"nosc", "elem", "midl", "high", "fsch", "scol", "asoc", "bach", "advd")
data$sch[data$sch == 0] <- 'nosc'
data$sch[data$sch == 1] <- 'elem'
data$sch[data$sch == 2] <- 'elem'
data$sch[data$sch == 2.5] <- 'elem'
data$sch[data$sch == 3] <- 'elem'
data$sch[data$sch == 4] <- 'elem'
data$sch[data$sch == 5] <- 'elem'
data$sch[data$sch == 5.5] <- 'midl'
data$sch[data$sch == 6] <- 'midl'
data$sch[data$sch == 7] <- 'midl'
data$sch[data$sch == 7.5] <- 'midl'
data$sch[data$sch == 8] <- 'midl'
data$sch[data$sch == 9] <- 'high'
data$sch[data$sch == 10] <- 'high'
data$sch[data$sch == 11] <- 'high'
data$sch[data$sch == 12] <- 'fsch'
data$sch[data$sch == 13] <- 'scol'
data$sch[data$sch == 14] <- 'asoc'
data$sch[data$sch == 16] <- 'bach'
data$sch[data$sch == 18] <- 'advd'
data$sch <- droplevels(data$sch)
barplot(table(data$sch))
```
Let's have a look at region variable.
```{r}
barplot(table(data$region))
```
The regions are equally distributed among the given variables.

```{r}
barplot(table(data$statefip))
unique(data$statefip)
```

```{r}
barplot(table(data$metro))
```
```{r}
barplot(table(data$relate))
```
```{r}
hist(data$age)
```
```{r}
barplot(table(data$sex))
```
Both genders are equally represented in the dataset.

```{r}
barplot(table(data$race))
```
```{r}
barplot(table(data$marst))
```
```{r}
barplot(table(data$nativity))
```

Let's plot the correlation matrix of the meaningful variables in out dataset.

```{r}
data.cat <- data[c("region", "statefip", "metro", "relate", "sex", "race", "marst", "nativity", "hispan", "sch", "occupation", "industry", "classwkr", "union", "ftype")]

chisq.matrix <- function(x) {
  names <- colnames(x);
  ndim <- length(names)
  pvals <- matrix(nrow=ndim, ncol=ndim, dimnames = list(names, names))
  stats <- matrix(nrow=ndim, ncol=ndim, dimnames = list(names, names))
  for (i in 1:ndim) {
    for (j in i:ndim) {
      test <- chisq.test(x[,i],x[,j], simulate.p.value = TRUE)
      pvals[i,j] = test$p.value
      pvals[j,i] = pvals[i,j]
      stats[i,j] = test$statistic
      stats[j,i] = stats[i,j]
    }
  }
  
  return (list("p.values"=pvals, "statistics"=stats))
}

mat <- chisq.matrix(data.cat)
#heatmap(mat$p.values)
heatmap(mat$statistics)
```
We can see theat *region* is correlated with *statefip*, *relate* with *ftype* and *race* with *hispan*. So we will use only 1 of the variables in e ach pair: *region*, *relate* and *race*.

Let's define the variables we will use in the regression.
```{r}
data$realincwage <- data$incwage * data$inflate

hist(data$realincwage)
  
data.reg <- data[c("year", "numprec", "region", "metro", "relate", "age", "sex", "race", "marst", "nativity", "sch", "occupation", "industry", "classwkr", "union", "realincwage")]

attach(data.reg)
```


# Linear regression
We will build the linear regression to identify which factors influence income the most.
```{r}
reg.out <- lm(log(realincwage) ~ . -numprec, data = data.reg, weights=numprec)
summary(reg.out)
```
```{r}
reg.out <- lm(log(realincwage) ~ ., data = data.reg)
summary(reg.out)

plot(fitted.values(reg.out), residuals(reg.out), pch=20)
abline(h=0)
```



